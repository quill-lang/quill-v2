\documentclass[UKenglish, 11pt, a4paper, parskip=half]{scrbook}
\usepackage[utf8]{inputenc}
\usepackage[UKenglish]{babel}
\usepackage{makecell}
\usepackage{microtype}
\usepackage[pdfa]{hyperref}
\hypersetup{colorlinks=true, linktoc=all}
\usepackage[style=numeric]{biblatex}
\addbibresource{refs.bib}
\defcaptionname{UKenglish}{\bibname}{References}

\usepackage{fontspec}
\setmainfont[Ligatures=TeX]{TeX Gyre Pagella}
\setmonofont{Fira Code}[
    Scale=MatchLowercase,
    Contextuals=Alternate  % Activate the calt feature
]
\usepackage{listings}
\usepackage{lstfiracode} % https://ctan.org/pkg/lstfiracode
\lstset{
    %language=C++,
    style=FiraCodeStyle,   % Use predefined FiraCodeStyle
    basicstyle=\ttfamily   % Use \ttfamily for source code listings
}

\newcommand{\code}[1]{\lstinline{#1}}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{physics}

\theoremstyle{definition}
\newtheorem*{definition}{Definition}
\newtheorem*{claim}{Claim}
\newtheorem*{theorem}{Theorem}
\newtheorem*{proposition}{Proposition}
\newtheorem*{lemma}{Lemma}
\newtheorem*{corollary}{Corollary}
\newtheorem*{example}{Example}

\newcommand{\Empty}{{\vb{0}}}
\newcommand{\Unit}{{\vb{1}}}
\newcommand{\unit}{{\vb{\star}}}
\DeclareMathOperator{\id}{id}

\title{Quill and Feather Language Specifications}
\author{zeramorphic}

\begin{document}

\frontmatter

\maketitle

\tableofcontents

\chapter{Preface}

The Quill language is a large project, and it has proven difficult to manage such a large project without adequate planning and formal specification.
Feature bloat has led the language to a place where its current state is difficult to improve upon incrementally; entire crates of code must be thrown out in order to make meaningful refactors.
This specification aims to codify the functions of each part of code in such a way that when they are implemented, their design is already well thought-out, and further changes can be made without extensive refactoring or modification.

The document begins with defining Quill's aims and requirements, and the consequences this has on the language.
In theory, every feature of Quill should be explained in this document, with a clear rationale for the decisions made and the tradeoffs they imply.
The design process of Quill should be made clear for any reader sufficiently familiar with language design.

It then continues, describing the various language features of Feather and Quill, making formal definitions where useful for further analysis.
A general background knowledge of type theory and lambda calculus, as well with general language design theory, will be assumed, although merits of various type systems will be discussed in depth in future sections.

\chapter{Design principles}

\section{Quill and Feather}

This project aims to codify the languages of Quill and Feather.
They are innately linked, but are not the same.
Put simply, Quill is the user-facing language, which is transpiled into Feather, a functional intermediate language.
This is then compiled to an executable file.
The reasoning behind this choice to separate Quill from Feather is explored later.

Occasionally, we describe features that `Quill has', especially when the separation of responsibility between Quill and Feather is not yet established, however they may apply equally to both languages.
Quill, being the name of the `end product', is simply used as a synonym for the project in its entirety.

\section{Goals}

\subsection{Opinions and facts}

In this section, I will outline several reasons why certain paradigms were chosen for Quill's design.
It is important to emphasise that when I say `favour X over Y', I do not mean that statement as a blanket truth for programming as a discipline; rather, I am designing a language with such features because I wish one were to exist.
The answers to the questions posed below will likely have different answers to different programmers, and different languages likely exist that satisfy those requirements.
Quill is created simply because there is no language that adequately meets the requirements I would wish for a language, it is not a statement that those requirements are objectively good.

\subsection{Outline of goals}

Quill must be, first and foremost, a functional efficient programming language.
It is worth elaborating on the definitions and implications of these words, as well as the reasons for having chosen such words.

\subsection{Functional programming}

By \textit{functional}, we refer to functional programming.
On a macroscopic level, any program accepts some input, performs some calculations, and produces some output.
Where functional and imperative programming languages differ is the ways in which programmers are empowered to perform such calculations.

Functional programs are, in and of themselves, functions.
Those functions are constructed by the composition of other functions, repeatedly applying transformations to input data to convert it into new data, until a final result is calculated, at which point it is returned to the user.
Conversely, an imperative program typically manipulates input data directly, by mutating it, as opposed to transforming it with functions.

There are several advantages to functional programming when compared to imperative programming.
\begin{itemize}
    \item A functional program is, by its very nature, comprised of distinct transformative functions.
    These functions can naturally be easily separated from each other and from the data they operate on.
    The modularity encourages the use of abstraction, and decouples the functions themselves from their implementation details, which allows for potentially easier refactoring.
    \item Combinators abstract away boilerplate.
    Off-by-one errors are difficult to introduce when your loop is encapsulated inside a \code{map} or \code{fold}.
    \item In \textit{pure} functional programming, functions have no side effects.
    In particular, they are \textit{deterministic}; a function's output depends only on the function's inputs, regardless of the execution context.
    This allows for far superior static analysis of programs.
    Any expression may be safely and easily evaluated at compile time due to this determinism, which removes the need for complicated \code{constexpr} mechanics or code colouring.
    \item Immutability is preferred by default.
    Whole transformations of input variables are more idiomatic than gradually updating a variable's contents.
    This prevents bugs which may be introduced by concurrent modification, such as altering the contents of a list while iterating through it.
    Code often operates on the assumption that certain variables will not change; this paradigm codifies and enforces that assumption.
\end{itemize}

\subsection{Programmer versus compiler}

Much of the `benefits' of functional programming outlined above are predicated on a tacit assumption: that it is worth foregoing direct control over the instructions being executed in exchange for fewer bugs and a more robust programming experience.

Fundamentally, every language must define a split of power between the programmer and the compiler.
Languages in the C family often give the programmer direct control over the system's memory, leaving allocation and deallocation up to the programmer.
By allowing the programmer such direct access to the sequence of instructions that will be executed, this forces the programmer to assume the responsibility of writing correct code.
The compiler, to such a programmer, is a tool to take ideas and formalise them into a logical system.

Higher-level languages take a different stance; any gain in performance achieved as a result of direct memory management (for example) is eclipsed by the cognitive load such a system places on the programmer, and the time cost that is incurred when inevitable memory-related bugs are found and must be fixed.

More modern programming languages understand the compiler not as a tool to formalise some already-perfect idea into a logical language, but instead as a partner, which will validate your decisions and ensure that certain logical invariants are upheld.
Of course, this comes at the cost of flexibility---for example, by denying mutability outright, certain algorithms like quicksort become nontrivial to express.

One particularly prominent example is the Rust compiler, notorious for novice users `fighting the borrow checker'.
Rust's borrow checker statically analyses memory use using an ownership-based memory model, and thus eliminates whole classes of bugs at compile-time, such as dangling and null pointers.
This comes at the cost of forcing the programmer to prove to the compiler that memory management is safe at compile time.
The borrow checker is quite conservative in what it accepts, and if in doubt will reject an otherwise valid program.
Certain constructions, which would be idiomatic in related languages like C++, are invalid under the rules of the borrow checker in Rust, and many users struggle to understand why the borrow checker is rejecting clearly working code.
However, once one is familiar with the borrow checker, it becomes clear that it is an ally, not an adversary: delegating some amount of power to the borrow checker is a compromise that allows you to be certain about the memory properties of a program at the expense of absolute freedom.

\subsection{When to compromise with the compiler}

At the heart of Quill is the supposition that it is worth trading absolute freedom for compile-time guarantees, provided that the expense incurred is not `too significant'.
Unfortunately, what tradeoffs are too significant is a problem of opinion, not of logic, so this remains an unsatisfying conclusion to this analysis.
We provide a number of heuristics to guide our future discussion.
Note that these heuristics are very opinionated, and do not apply equally to programming as a whole.
A number of these assertions originate from the `Zen of Zig', a description of the goals of Zig and its community, accessible on the command line by running \code{zig zen}.

We assert that the language should be built to deal with large projects better than small ones.
Many programmers have experienced the bloat that arises when tools are used for longer than originally intended, and more and more time is spent forcing yet more features into such programs.
It is often the case that a small program unintentionally becomes large; it is rarely the case that a large program unintentionally becomes small.
For this reason, programs should be built with the intent to scale, even if this is not an initial design goal.

Catching bugs at compile time is superior to catching them at runtime.
Clearly, this belief is not held by all programmers; for instance Python does not have a strict notion of compile time and runtime, and almost all errors (except, of course, syntax errors) can occur at any point during program execution.
There is also the disadvantage that an incomplete program cannot be run at all.
There is merit in being able to execute partially completed, logically unsound, programs---provided that this be for the purpose of debugging and aiding development, and not for use in production code.
Languages that have more compile-time guarantees are often harder to get a running program, but often easier to get a correct program once it does run.
Given that a common objective is to create correct and sound code, even if that means more initial time in development, means that we err on the side of compile-time guarantees when possible.

Clarity in reading and understanding code is favoured over ease of writing code.
Code is written only once, but read many times.
By making relations clear between different parts of a program, for example by establishing strict visibility rules, large programs become easier to understand.

Code should be designed in a modular manner.
In any large project, refactoring and redesigning certain modules is inevitable.
The programming language should actively work to make such tasks easier to perform.
By promoting a culture of modular code design, these inevitable processes become significantly less of a burden.
Independent, modular parts are much more simple to reason logically about, when compared to large interlinked processes.
Given the emphasis on reading (and understanding) code over writing it, a modular design is instrumental.

Data should be decoupled from the operations performed on them.
This opposes the paradigm of object-oriented programming, which often ties together any data with its functions.
With languages like Java, this paradigm falls into the problem that all functions \textit{must} be contained with a class, degrading the meaning of a class as an object that may be instantiated with an inheritance hierarchy.
Inheritance-based languages also suffer from the diamond problem.
These issues are not sufficient to abandon the object-oriented paradigm completely---indeed, object-oriented programming has many benefits, especially in particular domains with concrete inheritance hierarchies---but are enough for our purposes to favour an alternate paradigm.

Processes should be designed in a sufficiently abstract way as to know only what it must.
If a function's argument may be of an arbitrary type, there is no use in specifying it; indeed, this can only introduce bugs, when implementation details are unintentionally relied on.
Whenever possible, features like Rust's traits or Haskell's typeclasses should be used to intentionally `forget' unneeded information.

\subsection{Efficient programming}

The word \textit{efficient} carries a double meaning: computational efficiency, and efficiency of writing and reading code.
Quill attempts to satisfy both of these definitions, to an extent.
The commitment to efficiency of reading code follows from the previous asserted goals, but efficiency of writing code does not.
Of course, Quill would ideally be an efficient language to write code in, but this must come at a lower priority.

Under the aforementioned constraints, Quill should be the most \textit{computationally} efficient language possible.
It is important to emphasise here that speed will \textit{never} come at the expense of one of Quill's other goals.
Quill will never become a `functional C'; the level of independence offered over memory management offered (and required) by C conflicts with, for example, the axiom that catching bugs at compile time is better than catching them at runtime.
When such languages as Rust exist, which demonstrate the ability for a modern language to have neither a garbage collector nor unsafe memory access, it is difficult to justify the inclusion of such a feature into Quill.

However, when possible, efficient constructs will be favoured over inefficient ones.
Perhaps most importantly, Quill is a compiled language, not a just-in-time compiled or interpreted language.
This provides a clear speed benefit, and the only cost for the programmer is perhaps an increase in compilation time.

This analysis would imply that the best choice for Quill should be a Rust-like ownership system.
Such a system has not seen prominence in functional programming languages to date, but we intend to show that this is not as a result of incompatibility of the two paradigms---rather, ownership-based memory management is simply a sufficiently new concept such that many languages have not caught up with the development yet.

Denying the ability for the programmer to write computationally efficient imperative constructs places a burden on the compiler to translate idiomatic functional programs into efficient imperative ones.
As a basic example, tail-recursion can be easily translated into iteration.
Constructs such as lambda abstractions and higher-order functions can in theory be translated into ordinary functions whose efficiency matches that of C.

Not all efficiency constraints are in direct opposition to some of Quill's goals.
For example, compile-time optimisation and static analysis is greatly aided by Quill's emphasis on static typing and modular design.

Concurrency may also be implemented in a way that easily aligns with Quill's objectives, by utilising concepts such as the \code{Send} and \code{Sync} marker traits from Rust.
Again, compile-time guarantees are used to reduce or eliminate the possibility of runtime bugs.

\section{Requirements}

The above goals naturally lead to the following requirements for Quill as a language.

\subsection{Reliability of performance}

For Quill to be as efficient as possible we require a departure from conventional functional programming models, abandoning thunk-based computation in favour of translation to imperative instructions.
Values will be evaluated eagerly, unless their values are placed behind (for example) a function which must be invoked to compute the value.

In line with adopting an ownership-based memory model, a garbage collector (or a runtime in general) will likely be unnecessary.

\subsection{Immutability by default}

Functions should be pure.
Pure functions lend themselves better to static analysis and static optimisation, eventually leading to more performant programs with fewer bugs.
This naturally entails referential transparency and variable immutability as a key principle.
In a similar way, recursion is to be preferred over iteration.

\subsection{Static type system}

A static type system prevents many classes of runtime bugs, so it should be used in Quill.
Assuming a static type system is used, the functional programming paradigm requires many features in such a type system, such as higher-order functions and higher-kinded types.

Haskell has several language extensions designed to make the type system more expressive, and this comes at the cost of compiler bloat.
An alternative is to manipulate abstractions as values \cite{ScrapYourTypeClasses}.
This has the advantage of allowing the programmer more flexibility when manipulating abstractions, but requires higher-rank functions to be usable directly inside data structures.
For Quill, which will have heavy compile-time code manipulation, this seems to be a good choice.
Such abstractions-as-values can be optimised away statically into plain function calls.

It is also possible to represent types themselves as values \cite{ZigComptimeTypes}.
For a similar reason, this makes sense to implement in Quill.
This will, however, introduce some subtleties about type equivalence and naming.
These will be addressed later.

Arguably, representing everything as a value distils functional programming into its purest form.
Formal type theory often represents types as values, and deals with this by constructing a hierarchy of universes to contain types of types \textit{ad infinitum} \cite[p.~24]{hottbook}.

Thus, we arrive at another axiom for Quill (and hence Feather) to follow: everything is a value.

\subsection{Everything is a value}

In letting types and abstractions be values, the compiler is obligated to perform certain optimisations.
Types cannot be represented in compiled machine code in the same way they can be represented in Feather, so it falls on the compiler to deduce all types at compile time.
Higher-rank functions are used often in abstractions, such as in functors, which have a \code{map} function generic over any input type.
Clearly, the types used inside the functor must be determined statically and converted to ordinary functions so that types do not need to be represented at runtime.
This also adds the compile-time benefit of optimisation for specific input types; for example, a \code{memcpy} would be unnecessary if the type being copied is zero-sized.

Multiple dispatch from Julia and related languages can be emulated at compile-time by simply allowing the implementation of an abstraction used to be chosen at the time of the function call, rather than forced by the type system \cite{MultipleDispatch}.
In particular, by providing various implementations of an abstraction to the compiler itself, the compiler can choose the most appropriate abstraction for the task at compile-time using specialisation rules---although since abstractions are values, the programmer is of course free to specify which abstraction to use manually.

\subsection{Code generation}

Since everything is a value, naturally Quill and Feather code should be values.
It stands to reason that syntax extensions themselves should be writable in the same way as normal Quill code, in a functional style.
The compiler should be able to evaluate such functions at compile time.
This foregoes the typical need for a macro system like in C, by simply allowing Quill to be its own macro system.
Rust's procedural macros fill a similar role, in that they use Rust code to generate more Rust code, and can even parse code blocks and apply transformations \cite{ProcMacros}.
In accordance with the principle of modularity, Quill's language design should be minimal yet expressive, and syntax extensions should then provide the necessary conveniences for developing idiomatic functional code.
For example, monadic \code{do} blocks may not be part of the base language.

\section{High-level design}

In this section, we outline the different parts of the Quill project, their responsibilities, and how they interact.
Each part should be represented as one or more distinct and non-hierarchical modules.
In particular, any shared data between two parts should be realised as a distinct shared module, not by including one part as a dependency of another.
These parts will be presented roughly chronologically in the order they are used to compile a Quill program.

\subsection{Lexer (\code{lex})}

Quill programs are read from an input file, or standard input.
The resulting stream of Unicode code points is converted into a stream of \textit{tokens}, logically indivisible chunks that have a type.
For example, a symbol such as \code{/} is a token, and a string such as \code{"Hello, world!"} is also a token.

Then, token streams are converted into \textit{token trees}, which are pairs of brackets of matching type and their contents, such as \code{(1 + 2)}.
Naturally, token trees may be nested.

The lexer supports syntax extensions, which alter the rules it uses to classify tokens.
For instance, a syntax extension could be used to convert \code{10m} into \code{metres 10}.
The resulting code \code{metres 10} will be automatically enclosed in a token tree, so that operator precedence is automatically handled, unlike in the C preprocessor.

\subsection{Parser (\code{parse})}

Token trees from the lexer are analysed to check that they match certain patterns defined either by the Quill compiler or by syntax extensions.
Each pattern may contain sub-patterns that also need to be parsed recursively.
Names are resolved.
This results in an untyped abstract syntax tree.
The nodes of this abstract syntax tree represent expressions or top-level definitions such as functions.
Syntax extensions cannot create new node types.
Many nodes in the syntax tree will be given a type, and most nodes in the tree will provide some typing information for the type checker, such as equivalence relations between types of certain nodes.

\subsection{Type checker (\code{typeck})}

The type checker infers types of all variables in a given expression, given the constraints from the parser.
This may need to execute arbitrary Quill code, especially when types are manipulated as values.
Thus, this and almost all future parts of the compiler may be executed in parallel.
This results in a typed syntax tree.

\subsection{Feather transpiler (\code{feathergen})}

Typed syntax trees are converted into Feather, an intermediate language that can be executed and compiled to machine code.
Expressions in Feather are based on a modified version of \textit{administrative normal form} (ANF), taking influence from \textit{K-normal form} (KNF).
This representation allows many code transformations and optimisations to be performed \cite{ANFContinued}, while retaining the semantic content of regions to be used for lifetime analysis \cite{KNF}.

\subsection{Interpreter (\code{interpret})}

Feather code can be evaluated directly without compilation.
The resulting code will likely run slower than compiled code, but no expensive code generation or linking step is required.
This is used to execute expressions at compile time, such as type manipulation.

\subsection{Monomorphisation (\code{mono})}

Static analysis on Feather expressions is performed, and all values of runtime-incompatible types, such as types and higher-rank functions, are deduced.
The resulting code is duplicated for each possible (semantically different) value of these values, and usages are updated so that the code no longer depends on higher-rank functions or types as values.
At this stage, implementations of abstractions can be resolved automatically.

\subsection{Code generation (\code{codegen})}

Feather programs must be compiled into machine code.
This task is handled by the \code{codegen} module.
At a high level, this module takes monomorphised Feather code and converts it into LLVM IR, which will be passed off to an LLVM compiler which will convert it to machine code.
This process involves the conversion of function paradigms such as recursion into imperative constructs such as iteration, or functional transformations into mutation where applicable.
It also must provide native implementations of standard library functions that cannot be expressed without some interaction with the OS or kernel.
This also acts as a frontend for linking the final object files together into an executable.

\subsection{Diagnostics and error handling (\code{diag})}

Using this diagnostic infrastructure, errors and warnings may be emitted with reference to the actual code that caused the error, displaying an easy-to-read representation of the error on the command line.

\subsection{Query-based compilation}

To increase and enforce modularity, the functionality each of the above modules is typically represented using queries.
This has seen use in Rust \cite{RustDevGuideOverview}, which has been seen to enhance incremental compilation among other modularity benefits.
This will also empower the compiler to act in parallel.

\section{Prerequisites}

To aid in our descriptions, type theoretic syntax will be used.
We begin here by presenting an informal description of many of the key principles of intuitionistic type theory, which can be found in the book `Homotopy Type Theory' \cite{hottbook}.
Certain prerequisite knowledge, such as the use of \( A \to B \) to denote the type of pure functions from \( A \) to \( B \), or the typed lambda calculus, will be assumed.
However, more complex type-theoretic practices, specifically those which differ between authors, are detailed below.

In this specification, we assume the existence of a hierarchy of universes.
\[ \mathcal U_0 \colon \mathcal U_1 \colon \mathcal U_2 \colon \cdots \]

\begin{definition}
    An object \( A \) is a \textit{type} if \( A \) inhabits some universe \( \mathcal U_i \).
    We write \( A \colon \mathcal U_i \).
    We can also write \( A \colon \mathcal U_j \) if \( j \geq i \).
    Given a universe \( \mathcal U_i \), a type \( A \) is called \textit{small} if \( A \colon \mathcal U_i \).
    Assuming indices \( i \) may be assigned in a consistent way in a given context, the indices may be omitted, and we can write \( A \colon \mathcal U \).
\end{definition}
\begin{definition}
    A \textit{judgment} is a statement of the form \( a \colon A \).
    If \( A \) is a type that represents a proposition, then \( a \) is a \textit{witness} to the provability of \( A \).
\end{definition}

Even though type theory is a powerful tool, some set theory will also be used where it is less verbose than equivalent type-theoretic constructions.

\mainmatter

\part{Feather Language Specification}

\chapter{Syntax}

\section{Representations}

Feather is a strongly typed, functional, K-normal form intermediate language. It has two representations, an \textit{in-memory} representation, and a \textit{textual} representation.
These two representations fundamentally encode the same data; they are in isomorphism.
Hence, we will discuss here the textual representation, and leave the in-memory representation as an implementation detail.

\section{S-expressions}

\subsection{Atoms}

We begin our discussion of Feather by defining its core building blocks.
We assume the definition of the types \( \mathbb N \) of natural numbers \( 0, 1, \dots \), along with the usual arithmetic operations.
\begin{definition}
    An \textit{\( n \)-bit unsigned integer} is an element of \( \mathbb N \) strictly less than the value \( 2^n \).
    That is, \( x \) is an \( n \)-bit unsigned integer if there exists a value \( y \colon \mathbb N \) such that \( x + y = 2^n \) and \( y \neq 0 \).
    We construct the type of \( n \)-bit unsigned integers, written \( \mathbb N_n \colon \mathcal U_0 \).
    To preserve uniqueness of types, we will write \( x_n \) to denote the instance of \( x \) of type \( \mathbb N_n \).
    For clarity, the notation \( x_{\mathbb N_n} \) is also used.
\end{definition}
Let \( \mathbb Z \) be the type of all integers, created by generating a group from \( \mathbb N \) under addition.
\begin{definition}
    An \textit{\( n \)-bit signed integer} is an element of \( \mathbb Z \) not less than \( -2^{n-1} \), and strictly less than \( 2^{n-1} \).
    Likewise we construct the type of \( n \)-bit signed integers, denoted \( \mathbb Z_n \colon \mathcal U_0 \).
    Again, the notation \( x_n = x_{\mathbb Z_n} \) is used to refer to the instance of \( x \) that has type \( \mathbb Z_n \).
\end{definition}
\begin{definition}
    For \( n = 16, 32, 64, 128, 256 \), we define the \textit{\( n \)-bit floating point} type \( \mathbb F_n \colon \mathcal U_0 \) to be the quotient of \( \mathbb N_n \) by the equivalence relation defined by the IEEE 754 standard for floating point representation.
    Arithmetic is defined on this type as per the specification \cite{IEEE754}.
\end{definition}
\begin{definition}
    We define the Boolean type \( \mathbb B \colon \mathcal U_0 \) with elements \( \qty{\top, \bot} \), conventionally named `true' and `false'.
\end{definition}
\begin{definition}
    Let \( \mathbb U \colon \mathcal U_0 \) be the type of Unicode code points; its elements are 64-bit unsigned integers as defined above, tagged \( x_{\mathbb U} \) such that their type is not simply \( \mathbb N \).
\end{definition}
\begin{definition}
    Let \( \Empty \) be the \textit{empty type} with no elements.
    Let \( \Unit \colon \mathcal U_0 \) be the \textit{unit type} with one element \( \unit \colon \Unit \).
\end{definition}
These are exactly the primitive types used in Feather.
\begin{definition}
    An \textit{atom} is an element of type \( \mathbb N_n, \mathbb Z_n, \mathbb F_n, \mathbb B, \mathbb U, \Empty, \Unit \) for any valid \( n \).
    Note that all atoms have small type; that is, their types are all in the space \( \mathcal U_0 \).
\end{definition}

\subsection{Binary representations}
\begin{definition}
    A \textit{(binary) representation} of a type \( A \colon \mathcal U \) is an injective function
    \[ \rho \colon A \to \mathbb B^n \]
    for some \( n \colon \mathbb N \).
    We say that \( \rho \) represents \( A \) in \( n \) bits.
    Since \( \rho \) is injective, this implicitly defines the surjective function \( \rho^{-1} \colon \mathbb B^n \to A \) such that \( \rho^{-1} \circ \rho \equiv \id_A \).
    Note that if some \( x \colon \mathbb B^n \) is not contained in the image of \( \rho \), its value under \( \rho^{-1} \) is undefined \textit{a priori}.
\end{definition}
\begin{definition}
    A representation \( \rho \colon A \to \mathbb B^n \) in \( n \) bits is \textit{minimal} if, for all representations \( \sigma \colon A \to \mathbb B^m \) in \( m \) bits, we have \( m \geq n \).
    That is, the amount of bits required for the representation of \( \rho \) is minimal.
\end{definition}
\begin{definition}
    The canonical binary expansion for \( \mathbb N_n \), written \( \rho_{\mathbb N_n} \), is the base-2 representation of a number using \( n \) bits, where \( \top \) corresponds to a one, and \( \bot \) corresponds to a zero.
    The representation \( \rho_{\mathbb Z_n} \) works similarly, using two's complement.
    Floating-point representations are constructed in a similar way.
    Booleans are represented in a single bit using the identity map.
    The representation of Unicode code points uses a full 32 bits for convenience of word size.
    The unit type is represented in zero bits.
\end{definition}
It is then trivial to prove the following lemma.
\begin{lemma}
    The canonical representations of atomic types, with the exception of \( \mathbb U \), are minimal.
\end{lemma}

\subsection{Expressions and schemas}
\begin{definition}
    A \textit{symbol} is a string of Unicode code points, written as a string.
    The type of symbols is \( \mathbb S \).
    When written textually, symbols must be \textit{escaped} in such a way that they are unambiguously symbols.
    If the symbol contains any non-letter characters, symbols should be surrounded with quote marks \code{"} to disambiguate them.
    Standard C character escaping should be used to represent control characters and quote marks.
\end{definition}
\begin{definition}
    An \textit{S-expression} is either an atom, a symbol, or a list of S-expressions, denoted \code{(x y ... z)} where \code{x}, \code{y}, \code{z} are S-expressions.
    A \textit{schema} is a prescribed form of an S-expression; it ascribes types to S-expressions that fit a certain form.
    The symbols \code{*} and \code{+} are used as in Backus-Naur form.
    Note that \code{T*}, for example, is not an S-expression alone; it is a list of S-expressions which must be parenthesised in order to form an S-expression.
\end{definition}

\section{Expression syntax}

\subsection{Identifiers}

The following schemas specify identifiers and related types.

\begin{tabular}{r l p{6cm}}
    \code{Location} \( ::= \) & \code{(}\( \mathbb N_{32} \) \( \mathbb N_{32} \)\code{)} & line number, then column number, zero indexed \\
    \code{Range} \( ::= \) & \code{(Location Location)} & start location (inclusive), then end location (exclusive) \\
    \code{Name} \( ::= \) & \( \mathbb S \)\code{\ | (}\( \mathbb S \)\code{\ Range)} & the symbol itself then optionally the range at which it was written \\
    \code{QualifiedName} \( ::= \) & \code{(}\( \mathbb S \) \code{+)} & list of one or more name segments
\end{tabular}

A \textit{location} represents a place in some input code.
Since Feather is an IL, locations refer to a place inside a file of Quill code.
This allows error messages and debug symbols to refer to the original code.
A \textit{range} refers to a region of code, typically a single token or token tree.

Feather distinguishes between \textit{names}, which are single symbols representing in-scope items, and \textit{qualified names}, which represent a module hierarchy and then optionally refer to an item inside that hierarchy, depending on context.
Importantly, a qualified name with only one name segment is \textit{not} a name.

\subsection{Primitives}

\begin{tabular}{r l p{7cm}}
    \code{Primitive} \( ::= \) & \( \mathbb Z_{n} \)\code{\ |\ }\( \mathbb N_{n} \)\code{\ |\ }\( \mathbb F_{n} \)\code{\ |\ }\( \mathbb U \)\code{\ |\ }\( \mathbb B \)\code{\ |\ }\( \Unit \)
\end{tabular}

The \( n \) above may be substituted for valid integers.

\subsection{Expressions}

The type of expressions is \code{Expr}.
Expressions are organised into tree structures.
There exists a partial function \( p \colon \) \code{Expr} \( \to \) \code{Expr} which yields the parent expression if it exists.

\begin{definition}
    An expression is called \( n \)-\textit{binding}, or an \( n \)-\textit{binder}, if it creates \( n \) new local variables, assigning them values.
    An expression that binds no new local variables is called \textit{non-binding}.
\end{definition}

\begin{definition}
    The \textit{scope} of an expression is the set of expressions from which it can use variables.
    If there is a parent expression, the scope is the union of the scope of the parent expression together with the set containing the parent expression.
    Otherwise, the scope is the empty set.
    In the context of an expression \( e \), we say that an expression \( f \) is \textit{in scope} if \( f \in \mathrm{scope}(e) \).
\end{definition}

\begin{definition}
    Let \( e \) be an expression, \( b \) be an \( n \)-binding expression in scope of \( e \), and \( m \in \qty{0, \dots, n-1} \).
    The \textit{de Bruijn index} of \( c \) from \( e \), written \( i_e(b, m) \), is a constant referring to the \( m \)th bound variable in the binding expression \( x \).
    In particular,
    \[ i_e(b, m) = \begin{cases}
        i_{p(e)}(b, m) & \text{if } p(e) \neq b \text{ and is non-binding} \\
        i_{p(e)}(b, m) + k & \text{if } p(e) \neq b \text{ exists and is } k \text{-binding} \\
        n - m - 1 & \text{if } p(e) = b \\
    \end{cases} \]
    This definition orders all variables defined in scope in reverse order, assigning them de Bruijn indices of sequential natural numbers.
    Note that \( p(e) \) will always exist and this algorithm will always terminate since \( b \) was defined to be in scope of \( e \).
\end{definition}

Now that the requisite definitions have been made, we can define the schemas for expressions.

\begin{tabular}{r l p{7cm}}
    \code{DeBruijnIndex} \( ::= \) & \( \mathbb N_{32} \) \\
    \code{ExprContents} \( ::= \) & \makecell[l]{
        \code{(local DeBruijnIndex)} \\
        \code{| (borrow DeBruijnIndex)} \\
        \code{| (copy Expr)} \\
        \code{| (inst QualifiedName)} \\
        \code{| (ap Expr DeBruijnIndex)} \\ % note the A-normal form here
        \code{| (lambda Expr)} \\
        \code{| (new QualifiedName Expr*)} \\
        \code{| (newv QualifiedName\ }\( \mathbb S \) \code{\ Expr*)} \\ % construct a variant of an enum, the S is the variant name
        \code{| (destructure\ }\( \mathbb N_{32} \)\code{\ Expr)} \\ % the number is how many fields to destructure, mostly used for optimising all the de bruijn calculations
        \code{| (const\ }\( \mathbb S \) \code{\ Primitive)} \\
    } \\
    \code{ExprInfo} \( ::= \) & \code{(at Range) | (ty Expr) | (named Name)} \\
    \code{Expr} \( ::= \) & \code{ExprContents | (ExprInfo* ExprContents)}
\end{tabular}

% TODO: add lifetimes to borrow instructions?
% TODO: add a "create type" expression

Any variant of the \code{ExprInfo} tag may only be supplied once per expression.

The expressions may have additional information attached to them, denoting the location in code where the expression was written, the variable's type (which itself is an expression), or its name if one was given in Quill code.
The semantic meaning of each expression will be explored later; for now, it suffices to define which expressions are binders.
In particular, \code{lambda} expressions are 1-binding, \code{destructure n} expressions are \( n \)-binding, and all other expressions defined here are non-binding.

The absence of \code{let} expressions does not change the capabilities of the language.
Indeed, in pseudocode, we can apply the following rewrite rule.
\begin{lstlisting}
    let x = e1 in e2 => (lambda x . e2) e1
\end{lstlisting}

\section{Top-level hierarchy}

\subsection{Modules}

Expressions are stored for use in definitions.
Definitions are contained within modules.
Modules are each stored as their own S-expressions, and are not contained within any parent object.

\begin{tabular}{r l p{7cm}}
    \code{Visibility} \( ::= \) & \code{pub | priv} \\
    \code{DefInfo} \( ::= \) & \code{(at Range) | (ty Expr) | (vis Visibility) | (doc\ }\( \mathbb S \)\code{)} \\
    \code{Def} \( ::= \) & \code{(def DefInfo* Name Expr)} \\
    \code{ModuleInfo} \( ::= \) & \code{(file QualifiedName) | (doc\ }\( \mathbb S \)\code{)} \\
    \code{Module} \( ::= \) & \code{(module ModuleInfo* Def*)}
\end{tabular}

If present, a \code{doc} tag represents documentation for the definition or module in question.
Any variant of the \code{DefInfo} or \code{ModuleInfo} tags may only be supplied once per definition or module.
Definitions must have unique names within a module.

\subsection{Projects}

A project is comprised of a hierarchical structure of modules.
Since modules are not stored inside a parent object, the descriptions of modules inside projects simply refer to the name of the module.
The module itself can then be loaded from disk when necessary.
% TODO: sort out dependencies

\begin{tabular}{r l p{7cm}}
    \code{ProjectInfo} \( ::= \) & \code{(doc\ }\( \mathbb S \)\code{)} \\
    \code{ProjectModule} \( ::= \) & \code{(module QualifiedName)} \\
    \code{Project} \( ::= \) & \code{(project\ }\( \mathbb S \)\code{\ ProjectInfo* ProjectModule*)} \\
\end{tabular}

Any variant of the \code{ProjectInfo} tag may only be supplied once.

\section{Examples}
Here is an example of a simple module which exports a function to compute the sum of two integers.
For the purposes of this example, assume the existence of a function \code{add} of type \( \mathbb Z_{64} \to \mathbb Z_{64} \) stored within the module \code{core.i64}.
\begin{lstlisting}
(module (doc "Provides a function to compute the sum of two integers.")
    (def (vis pub) (doc "Computes the sum of two integers.") sum
        (lambda (lambda (ap (ap (new core i64 add) 0) 1)))
    )
)
\end{lstlisting}

\backmatter

\printbibliography

\end{document}
