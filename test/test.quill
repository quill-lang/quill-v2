def id::{u} : forall (A : Sort u), forall (a : A), A =
fn (A : Sort u), fn (a : A), a

def S_combinator::{u v w} :
forall (A : Sort u), forall (B : Sort v), forall (C : Sort w),
forall (z : forall (a : A), forall (b : B), C), forall (y : forall (a : A), B), forall (z : A), C =
fn (A : Sort u), fn (B : Sort v), fn (C : Sort w),
fn (x : forall (a : A), forall (b : B), C), fn (y : forall (a : A), B), fn (z : A), (x z) (y z)

def K_combinator::{u v} :
forall (A : Sort u), forall (B : Sort v), forall (a : A), forall (b : B), A =
fn (A : Sort u), fn (B : Sort v), fn (a : A), fn (b : B), a

def I_combinator::{u} :
forall (A : Sort u), forall (a : A), A =
fn (A : Sort u), fn (a : A), K_combinator::{u u} A A a a

inductive Punit::{u} 0 : Sort u
| star : Punit::{u}

inductive True 0 : Sort 0
| True.true : True

inductive Bool 0 : Sort 1
| false : Bool
| true : Bool

inductive Eq::{u} 2 : forall (A : Sort u), forall (a : A), forall (b : A), Sort 0
| refl : forall (A : Sort u), forall (a : A), Eq::{u} A a a

inductive Nat 0 : Sort 1
| zero : Nat
| succ : forall (n : Nat), Nat

def is_zero : forall (n : Nat), Bool =
Nat.rec::{1}
    (fn (n : Nat), Bool)
    true
    (fn (n : Nat), fn (previous : Bool), false)

def zero_is_zero : Eq::{1} Bool (is_zero zero) true =
refl::{1} Bool true

def one_is_not_zero : Eq::{1} Bool (is_zero (succ zero)) false =
refl::{1} Bool false

def add : forall (n : Nat), forall (m : Nat), Nat =
fn (n : Nat), Nat.rec::{1} (fn (k : Nat), Nat) n (fn (k : Nat), succ)

def one : Nat = succ zero
def two : Nat = succ (succ zero)
def four : Nat = succ (succ (succ (succ zero)))

def one_plus_zero : Eq::{1} Nat (add zero one) one = refl::{1} Nat one

def two_plus_two_is_four : Eq::{1} Nat (add two two) four = refl::{1} Nat four
