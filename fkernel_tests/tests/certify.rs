use std::{fmt::Debug, path::PathBuf, sync::Arc};

use fcommon::FileReader;
use fcommon::FileReaderStorage;
use fcommon::FileWatcher;
use fcommon::Intern;
use fcommon::InternStorage;
use fcommon::{PathData, Source, SourceType};
use fkernel::TypeChecker;
use fkernel::TypeCheckerStorage;
use fnodes::SexprParserStorage;
use salsa::Durability;

// Include the tests automatically generated by the build script.
include!(concat!(env!("OUT_DIR"), "/tests.rs"));

/// The main database that manages all the compiler's queries.
#[derive(Default)]
#[salsa::database(
    FileReaderStorage,
    InternStorage,
    SexprParserStorage,
    TypeCheckerStorage
)]
pub struct TestDatabase {
    storage: salsa::Storage<Self>,
}

impl Debug for TestDatabase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "<db>")
    }
}

impl FileWatcher for TestDatabase {
    fn watch(&self, src: Source) {}
    fn did_change_file(&mut self, src: Source) {}
}

impl salsa::Database for TestDatabase {}

fn run_test(file: &str) {
    let mut db = TestDatabase::default();
    db.set_project_root_with_durability(Arc::new(PathBuf::from("tests/src")), Durability::HIGH);
    db.set_no_read_from_disk_with_durability(false, salsa::Durability::HIGH);

    let source = Source {
        path: db.intern_path_data(PathData(
            file.split("/")
                .map(|segment| db.intern_string_data(segment.to_string().replace(".sexp", "")))
                .collect(),
        )),
        ty: SourceType::Feather,
    };

    let result = db.certify(source);
    for report in result.reports() {
        report.render(&db, std::io::stdout());
    }
    assert!(result.reports().is_empty());
}
